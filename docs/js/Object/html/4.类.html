<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<style>
</style>
<body>

</body>
<script>
/*
// 函数变量提升
console.log(FunctionExp);  // undefined
var FunctionExp = function () {
};
console.log(FunctionExp); // function (){}

console.log(FunctionDec); // FunctionDec (){}
function FunctionDec() {
}

console.log(FunctionDec); // FunctionDec () {}

console.log(classExp);  // undefined
var classExp = class {
}
console.log(classExp); // class {}

console.log(classDec);  // ReferenceError: ClassDeclaration is not defined
class classDec {
};
console.log(classDec); // class {}
*/

// 函数只受函数作用域限制 类受块级作用域限制
/*
{
    function functionExp() {}
    // 受块级作用域限制
    class classExp {}
}
console.log(functionExp);// functionExp() {}
console.log(classExp); //  Uncaught ReferenceError: classExp is not defined
*/


/*// 类的构成
// 空类定义 有效
class c1 {
}

// 有构造函数的类 有效
class c2 {
    constructor() {
    }
}

// 有获取方法的类 有效
class c3 {
    get name() {

    }
}

// 有设置函数的类 有效
class c4 {
    set name(val) {

    }
}
// 有静态方法的类 有效
class c5 {
    static myTest() {
    }
}

let Person = class PersonName {
    identify() {
        console.log(Person);
        console.log(PersonName);
        console.log(Person.name, PersonName.name);
    }
}
let p = new Person();
p.identify();*/
/*
  // 实例化 类
   class Animal {}

   class Person {
       constructor(){
           console.log('person');
       }
   }
   class Vegetable {
       constructor() {
           this.name = 'apple'
       }
   }
   let a = new Animal();
   let b = new Person();
   // 使用new 操作符会调用该构造函数  person
   let c = new Vegetable();
   console.log(c.name); // apple
   */

/*
 // 实例化类时传参
 class Person {
     constructor(name) {
         console.log(arguments.length);
         this.name = name || null
     }
 }
 let p1 = new Person  // 0
 console.log(p1.name); // null

 let p2 = new Person(); // 0
 console.log(p2.name); // null
// 传入参数
 let p3 = new Person("sans") // 1
 console.log(p3.name); // sans
 */

/*
class Person {
    constructor(flag){
        this.foo = 'foo';
        if(flag){
            return {
                bar : 'bar'
            }
        }
    }
}
let p1 = new Person,
    p2 = new Person(true);
console.log(p1); // Person {foo: "foo"}
console.log(p1 instanceof Person); // true

console.log(p2); // {bar : 'bar'}
console.log(p2 instanceof Person); // false
*/


/*
// 类构造函数和构造函数的区别
function Person () {}
class Animal {}

// this指向window 挂载到window上
let p = Person();
let a = Animal();
// TypeError: class constructor Animal cannot be invoked without 'new'
*/

/*
// 类构造函数实例化
class Person {}
let p1 = new Person();
p1.constructor();
// Class constructor Person cannot be invoked without 'new'

// 使用构造函数的引用创建一个新实例
let p2 = new p1.constructor();
*/

/*// 判断类构造函数的类型
class Person {}

console.log(Person); // class Person {}
console.log(typeof Person); // function*/

/*
// 类 与 函数的相似性
class Person {}
function fn(){};
console.log(Person.prototype); // {constructor : f()}
console.log(fn.prototype); // {constructor : f()}
console.log(Person.prototype.constructor === Person); // true
*/

/*// 通过instanceof 判断构造函数是否出现在实例的原型链上
class Person {};
let p = new Person();
console.log(p instanceof Person); // true*/

/*// 通过 instanceof 判断 类的构造函数
class Person {}
let p1 = new Person();
console.log(p1.constructor === Person); // true 相当于 p.__proto__.constructor === Person
console.log(p1 instanceof Person);  // true
console.log(p1 instanceof Person.constructor);  // false

let p2 = new Person.constructor();
console.log(p2);  // ƒ anonymous() {}
console.log(Person.constructor); // ƒ Function() { [native code] }
console.log(p2.constructor === Person); // false
console.log(p2 instanceof Person); // false
console.log(p2 instanceof Person.constructor); // true*/


/*// 在数组中定义类
let classList = [
    class {
        constructor(id) {
            this.id_ = id;
            console.log(`instance ${this.id_}`);
        }
    }
]
function createInstance(classDefinition, id){
    return new classDefinition(id) // 相当于  return new class(id) 返回 class的实例
}
let foo = createInstance(classList[0],1024)  // instance 1024*/

/*
// 立即调用类表单时
let p = new class Foo{
    constructor(x) {
        console.log(x);
    }
}('bar'); // bar

/!*
 // 相当于
class Foo {
    constructor(x) {
        console.log(x);
    }
}
let p = new Foo('bar') // bar
*!/
*/

/*
// 实例成员唯一性
class Person {
    constructor() {
        // 使用对象包装类型定义字符串
        // 以此判断下方测试两个对象的相等性
        this.name = new String('Jack');
        this.sayName = () => {
            console.log(this.name);
        };
        this.nickName = ['Jake', 'J-Dog']
    }
}

let p1 = new Person(),
    p2 = new Person();
p1.sayName() // String {"Jack"}
p2.sayName() // String {"Jack"}
console.log(p1.name === p2.name); // false
console.log(p1.sayName === p2.sayName); // false
console.log(p1.nicknames === p2.nicknames); // false
p1.name = p1.nicknames[0];
p2.name = p2.nicknames[1];
p1.sayName(); // Jake
p2.sayName(); // J-Dog
*/


/*// 将类块中的方法定义为原型方法
class Person {
    constructor(){
        // 添加到this的所有内容，都会存在于不同实例
        this.locate = () => {
            console.log('instance');
        }
    }
    locate() {
        console.log('prototype');
    }
}
let p = new Person();
p.locate() // instance
Person.prototype.locate() // prototype*/

/*class Person  {
    name: 'sans'
}
// Uncaught SyntaxError: Unexpected identifier*/


/*// 类 获取或设置访问器
class Person {
    set name(newName){
        this.name_ = newName;
    }
    get name(){
        return this.name_;
    }
}
let p = new Person();
p.name = 'sans';
console.log(p.name); // sans*/

/*class  Person {
    // 定义的this存在于不同的实力上
    constructor() {
        this.locate = ()=> {
            console.log('instance', this);
        }
    }
    // 定义在类的原型上
    locate(){
        console.log('prototype', this);
    }
    // 定义在类本身
    static locate(){
        console.log('class', this);
    }
}
let p = new Person();
p.locate();  // instance, Person {}
Person.prototype.locate(); // prototype {constructor: ...}
Person.locate(); // class class Person{}*/

/*// 在类外部添加成员数据
class Person {
    sayName(){
        console.log(`${Person.greeting} ${this.name}`);
    }
}
//在类上定义成员数据
Person.greeting = 'My name is';
// 在类原型上定义成员数据
Person.prototype.name = 'sans';
let p =  new Person();
console.log(p);
p.sayName(); // My name is sans*/

/*// 在类的原型和本身上定义生成器
class Person{
    // 在类原型上定义生成器方法
    *createNicknameIterator(){
        yield 'Jack';
        yield 'Jake';
        yield 'J-Dog'
    }
    // 在类上定义生成器方法
    static *createNicknameIterator(){
        yield 'Butcher';
        yield 'Baker';
        yield 'Sans';
    }
}
let jobIter = Person.createNicknameIterator();
console.log(jobIter.next().value); // Butcher
console.log(jobIter.next().value); // Baker
console.log(jobIter.next().value); // Sans

let p = new Person();
let nicknameIter = p.createNicknameIterator();
console.log(nicknameIter.next().value); // Jack
console.log(nicknameIter.next().value); // Jake
console.log(nicknameIter.next().value); // J-Dog*/

/*// 将类变成可迭代对象
class Person {
    constructor() {
        this.nicknames = ['Sans','Jack','Ben']
    }
    *[Symbol.iterator](){
        yield  *this.nicknames.entries();
    }
}
let p = new Person();
for(let [idx, nickname] of p){
    console.log(nickname);
}
// Jack
// Jake
// J-Dog*/
</script>
</html>
