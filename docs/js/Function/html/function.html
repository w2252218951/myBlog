<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
/*// 以下两种方法都有效
let double = (x)=> {return 2 * x};
let triple = x => {return 3 * x};

// 没有参数时需要括号
let getRandom = ()=> { return Math.random();}

// 多个参数需要括号
let sum = (a, b) => { return a + b};

// 无效的写法
let mutiply = a,b => { return a * b};*/

/*// 以下两种方式都有效而且会返回相应的值
let double = x => {return x * 2};
// 箭头函数省略大括号会隐式的返回值
let triple = x => x * 3;
// 进行赋值
let value = {};
let setName = (x) => x.name = 'Sans';
setName(value);
console.log(value.name); // Sans
//无效的写法
let mutiply = (a,b) => return a * b*/


/*// 函数标识符 name
function foo(){};
let bar = function (){};
let baz = ()=> {};

console.log(foo.name);  // foo
console.log(bar.name);  // bar
console.log(baz.name);  // baz
console.log((() => {}).name); // ''
console.log(new Function().name); // anonymous*/

/*// 函数前缀 给设置函数 获取函数或者通过 bind实例化的函数会带有前缀
function foo(){};
console.log(foo.bind(null).name);
let dog = {
    years : 1,
    get age(){
        return this.years
    },
    set age(newAge){
        this.years = newAge
    }
}
let propertyDescriptor = Object.getOwnPropertyDescriptor(dog,'age');
// 相当于直接遍历调用上述方法
let propertyDescriptors = Object.getOwnPropertyDescriptors(dog);
console.log(propertyDescriptor);
console.log(propertyDescriptors);

console.log(propertyDescriptor.get.name);  // get age
console.log(propertyDescriptor.set.name);  // set age*/

/*// arguments的值始终与对应的命名参数同步
function add(num1, num2){
    arguments[1] = 30;
    console.log(arguments[0] + num2);
}
add(10,20) // 40*/

/*
// 将arguments对象包装在函数中然后传递给箭头函数
function foo(){
   let bar = ()=> {
       console.log(arguments[0]);
   }
   bar();
};
foo(5) // 5
*/

/*
// ECMA5.1之前设置默认参数
function making(name){
    name = (typeof name !== 'undefined') ? name : 'Henry'
    return `King ${name} VIII`
}
console.log(making());   //  King Henry VIII
console.log(making('Louis')); // King Louis VIII
*/

/*    // 使用 =  设置默认参数
    function making(name = 'Henry') {
        return `King ${name} VIII`
    }
    console.log(making('Louis'));   //  King Louis VIII
    console.log(making()); //  King Henry VIII*/

/*//将函数设置成默认参数
let romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI'];
let ordinality = 0;

function getNumerals(){
    // 每次调用后递增
    return romanNumerals[ordinality++]
}

function making(name = 'Henry', numerals = getNumerals()){
    return `King ${name} ${numerals}`
}

console.log(making());   // 'King Henry I'
console.log(making('Louis', 'XVI')); // 'King Louis XVI'
console.log(making());  // 'King Henry II'
console.log(making());  // 'King Henry III'*/

/*
  // 调用时不传第一个参数汇报材料
    function making(name = numerals, numerals = 'VIII'){
        return `King ${name} ${numerals}`
    }
    making()  //  Cannot access 'numerals' before initialization*/

/*
// 调用时不穿第二个参数会报错
function making(name = 'Henry', numerals = defaultNumeral) {
    let defaultNumeral = 'VII';
    return `King ${name} ${numerals}`;
}

making(); // defaultNumeral is not defined
*/

/*let values = [1, 2, 3, 4];

function getSum() {
    console.log(arguments);
    let sum = 0;
    for (let i = 0; i < arguments.length; ++i) {
        sum += arguments[i];
    }
    return sum;
}

console.log(getSum(values)); // 01,2,3,4
// arguments [[1,2,3,4]]
console.log(getSum.apply(null, values)); // 10
// arguments [1,2,3,4]*/

/*// 在普通函数和箭头函数中使用扩展操作符命令参数，同时可以设置默认参数
function getProduct(a, b, c = 1) {
return a * b * c;
}

let getSum = (a, b, c = 0) => {
return a + b + c;
};
console.log(getProduct(...[1, 2])); // 2
console.log(getProduct(...[1, 2, 3])); // 6
console.log(getProduct(...[1, 2, 3, 4])); /6

console.log(getSum(...[0, 1]));; //1
console.log(getSum(...[0, 1, 2]));; // 3
console.log(getSum(...[0, 1, 2, 3]));; // 3*/

/*// 通过扩展操作符将独立的参数整合为一个数组。
function getSum(...values){
    console.log(values); // [1, 2, 3]
    return values.reduce((total, pre)=> total + pre, 0)
}

console.log(getSum(1, 2, 3)); // 6*/

/*// 因为收集参数是可变的，所以将他作为最后一个参数
// 不行
function getProduct(...values, lastValue){}

// 可行
function ignoreFirst(firstValue,...values){
    console.log(values);
}
ignoreFirst(); // []
ignoreFirst(1); // []
ignoreFirst(1,2); // [2]
ignoreFirst(1,2, 3); // [2, 3]*/


/*// 通过收集参数实现与arguments相同的逻辑
let getSum = (...values) => {
    return values.reduce((total, pre) => total + pre, 0);
};
console.log(getSum(1, 2, 3)); // 6*/
/*console.log(sum1 (10, 10));  // sum1 is not defined
var sum1 = function(num1, num2){
return num1 + num2
}*/

/*// 通过 sort 方法进行数组对象中属性的排序
function createComparisonFunction(propertyName){
    return function(data1, data2){
    console.log(data1);
    console.log(data2,'-----------------');
    let value1 = data1[propertyName];
        let value2 = data2[propertyName]
        if(value1 < value2){
            return -1
        }else if(value1 > value2){
            return  1
        }else {
            return 0
        }
    }
}
let data = [
    {name: "Zachary", age: 28},
    {name: "Nicholas", age: 29},
    {name: "Sans", age: 22},
    {name: "John", age: 22},
]
data.sort(createComparisonFunction("name"));*/

/*// 经典的阶乘函数
function factorial(num){
    if(num <=1){
        return 1
    }else {
        return  num * function(num - 1)
    }
}*/

/*// 使用 arguments.callee 进行解耦
function factorial(num){
    if( num <= 1){
        return 1
    }else {
       // arguments.callee 是指向arguments对象所在函数的指针
        console.log(arguments.callee);
        return  num * arguments.callee(num - 1);
    }
}
let trueFactorial = factorial;
factorial = function(){
    return 0
}
console.log(trueFactorial(5)); // 120
console.log(factorial(5)); // 0*/
/*let test1 =  {
    name: 'test1',
    sayName: function (){
        console.log(this.name);
    }
}
test1.sayName() // test1
let name = 'test3'
let test2 = {
    name : 'test2',
    sayName: ()=> {
        console.log(this.name);
    }
}
test2.sayName()*/

/*function King(){
    this.royaltyName = 'Henry';
    // this 引用 King 的实例
    setTimeout(()=> {
        console.log(this.royaltyName);
    }, 1000)
}
function Queen(){
    this.royaltyNmae = 'Elizabeth';
    // this 引用 window 对象
    setTimeout(function() {
        console.log(this.royaltyNmae);
    },1000)
}
new King(); // Henry
new Queen() // undefined*/

/*function outer(){
    inner()
}
function inner(){
    console.log(inner.caller);
}
outer()
/!*ƒ outer(){
    inner()
}*!/*/

/*
// arguments.callee 指向的是arguments对象所在的函数的指针
function outer(){
    inner()
}
function inner(){
    console.log(arguments.callee.caller);
}
outer()
/!*ƒ outer(){
inner()
}*!/
*/


/*
// 通过 new.target 判断是否是构造函数
function King(){
    if(!new.target){
        throw 'King must be instantiated using "new"'
    }
    console.log('King instantiated using "new"');
}
new King(); // King instantiated using "new"
King(); // Uncaught King must be instantiated using "new"
*/

/*// 函数自有属性 length 用来判断命名参数的个数
function sayName(name){
    console.log(name);
}
function sum(num1 , num2){
    return num1 + num2
}
function sayHi(){
    console.log('h1');
}

console.log(sayName.length); // 1
console.log(sum.length); // 2
console.log(sayHi.length); // 0*/

function sum(num1 , num2){
    return num1 + num2
}
function callSum1(num1, num2){
    return sum.apply(this, arguments) // 传入 arguments 对象
}
function callSum2(num1, num2){
    return sum.apply(this, [num1, num2]) // 传入数组
}
function handleSum(num1, num2){
    return sum(...arguments)
}

console.log(callSum1(10, 10));
console.log(callSum2(10, 10));
console.log(handleSum(10, 10));
</script>
</html>
